# Git 
## Оглавление
1. [Введение](#1-введение)
    - [Что такое Git?](#11-что-такое-git)
        - [Установка Git](#111-установка-git)
2. [Основы Git](#2-основы-git)
    - [Конфигурация](#21-конфигурация)
    - [Создание репозитория, первый коммит](#22-создание-репозитория-первый-коммит)
    - [Git и права на файлы](#23-git-и-права-на-файлы)
    - [Git show, кто такие авторы и коммитер](#24-git-show-кто-такие-авторы-и-коммитер)
    - [Добавление файлов и директорий, git status](#25-добавление-файлов-и-директорий-git-status)
    - [Хороший коммит](#26-хороший-коммит)
    - [Зачем нужен индекс](#27-зачем-нужен-индекс)
    - [Коммиты без git add](#28-комиты-без-git-add)
    - [Удаление и переименование фалов](#29-удаление-и-переименование-файлов)
3. [Ветки](#3-ветки)
    - [Создание и переключение](#32-создание-и-переключение)
    - [Команда checkout при незакоммиченных изменениях](#32-команда-checkout-при-незакоммиченных-изменениях)
    - [Перенос незакоммиченых изменений](#34-перенос-незакоммиченых-изменений)
    - [Перенос веток "вручную"](#35-перенос-веток-вручную)
    - [Состояние отделённой HEAD](#36-cостояние-отделённой-HEAD)
    - [Восстановление предыдущих версий файлов](#37-восстановление-предыдущих-версий-файлов)
    - [Просмотр истории и старых файлов, символы ~, ^, @, поиск с :/](#38-просмотр-истории-и-старых-файлов-символы----поиск-с-)
    - [Слияние веток "перемоткой"](#39-cлияние-веток-перемоткой)
   

## 1. Введение
### 1.1. Что такое Git? 

- Хранилище истории разработки проекта
- Обмен историей разработки
    - ... и интеграция изменений
- Распределенная система 
    - ... с необязательным сервером
- Надёжная система
    - контрольные суммы
    - история есть у всех

[Подробный тьюториал тут](https://www.youtube.com/watch?v=W4hoc24K93E&list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb&index=2 "видео на ютюб")

#### 1.1.1. Установка Git

- Linux:
    - apt-get install git
    - yam install git
    - ...
- Mac
    - Terminal / iTerm:
        - git
    - Homebrew / Macports

## 2. Основы Git
### 2.1. Конфигурация
- `git config`
- `git config user.name "Ekaterina Shchekotikhina"`
- `git config user.email asti.katerina@gmail.com`

Эти настройки лучше делать глобальными, а не для каждого проекта:

- `git config --global user.name "<Ekaterina Shchekotikhina>"`
- `git config --global user.email <asti.katerina@gmail.com>`
- `git config --global alias.sayhi '!echo "hello"; echo "from git"' (теперь можно использовать git sayhi)`

### 2.2. Создание репозитория, первый коммит
- `git init`
- `git status`
- `git add .` | `git add <index.html>`
- `git commit -m '<here we write our commit message>'` (флаг **-m** позволяет передавать описание комита сразу, а не добавлять его позднее в текстовом редакторе)

### 2.3. Git и права на файлы

Исполнимый (100644) и неисполнимый (100744) файл

- `chmod +x <index.html> | chmod -x <index.html>`

### 2.4. Git show, кто такие авторы и коммитер

Отображение информации по коммиту: 

- `git show`
- `git show --pretty=fuller`

Изменение данных комитера: 

- `git commit --author='<Santa Clause>\<santa@me.com\>' --date='<01.01.2025>'`

### 2.5. Добавление файлов и директорий, git status

git не умеет добавлять пустые дирректории (**git add** не сработает), чтоб сохранить новую дирректорию нужно сразу создать в ней рабочий файл, или вспомогательный файл **.gitkeeper** Затем можно добавить всю дирректорию с помощью **git add .**

Если случайно добавили в индекс ненужные фалы можно их убрать:

- `git reset HEAD <.DS_Store>`

в идеале добавлять ненужные файлы в .gitignore в корне проекта или на всем компьютере: 

- `echo "<.DS_Store>" >> ~/.gitignore_global`
- `git config --global core.excludesFile ~/.gitignore_global`

### 2.6. Хороший коммит

- [x] ***Atomic and consistent***

Хороший коммит должен быть атомарным (1 отдельная вещь: feature/fix) и консистентным (завершенным), т.е. всё должно работать исправно до и после комитта.

- [x] ***Commit early. Commit often.***

Так чтобы легко можно был сделать откат. 

- [x] Хорошее описание комитта - делает его понятным комадне и тебе самому даже через 100 лет.

- [ ] ~~непонятно или отсутствует вовсе~~

### 2.7. Зачем нужен индекс?

Двухступенчатая система сохранения, при этом мы можем выбрать не только  отдельные файлы или дирректории, но и отдельные фрагменты в рамках одного файла, если они были в разных локальных сохранениях <kbd>Command</kbd>+<kbd>S</kbd>, для этого используем флаг *-p*

- `git add -p <index.html>`

```zsh
ekaterina@Ekaterinas-MacBook-Air Slonit % git add -p hello.html
diff --git a/hello.html b/hello.html
index 30f25bf..87552ca 100644
--- a/hello.html
+++ b/hello.html
@@ -9,7 +9,7 @@
 </head>
 <body>
     <header>
-        <h1>Welcome to Slonit!!!</h1>
+        <h1>Welcome to Slonit!!! Проверяем флаг -p </h1>
         <p>first change</p>
     </header>
     <main>
(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]?
```

выбираем опции **y = yes**, **n=no**, затем переходим к следующему фрагменту кода.
**?=** показать значение всех опций

```html
@@ -21,7 +21,6 @@
     <script>
         helloGitty();
     </script>
-    <p>...Unfinished changes 2...</p> 
-    <p>...Unfinished changes 3...</p>
+    <p>...а тут у нас второй hunk...</p> 
 </body>
 </html>
\ No newline at end of file
(2/2) Stage this hunk [y,n,q,a,d,K,g,/,e,?]? n
```

### 2.8. Комиты без git add

Можно быстсро сделать коммит без двухступенчатого переноса в индекс, для этого используем флаг **--all** или **-a**, флаг **-m** для сообщения можно прикрепить к нему же и получится **-am**

- **git commit -am '<сообщение с описанием коммита>'**

или можно быстро закомитить отдельный файл указав его путь 

- `git commit -m '<сообщение с описанием коммита>' .index.html`

Важно: эти два варианта не добавят изменения из файлов, которые игнорируются гитом и не были ранее проиндексированы

Флаг **-a** позволяет закомитить всё из текущей директории, а флаг **-A** всё из проекта в целом, независимо от того, из какой дирректории он вызван.

Также можно сделать свой alias: 

- `alias.commitall '!git add .; git commit'`

Важно поддерживать атомарность комита, т.е. комитить всё имеет смысл только, если добавление какой-то функциональности затронуло несколько файлов. 


### 2.9. Удаление и переименование файлов

удаление файла - добавляем и коммитим также как и изменения в нем.
переименование = удаление старого файла и создание нового 

- `git rm -r <src>` = `git -r src + git add <src> `
- `git rm -r <src> --cached` - удаляет из индекса, но оставляет в рабочей дирректории и делает файл/директорию неотслеживаемым/ой при попытке удалить файл, который несохранен нигде git выдает предупрежнения для предотвращения безвозвратной потери данных. Это можно игнорировать,  используя флаг -f или -- force

- `git rm -f index.html`

## 3. Ветки
### 3.2. Создание и переключение  

- `git branch -m <main>` - переименовываем основную ветку если нужно, *main* это классика, иногда это может быть *trunck* | *development*
- `git branch -v` - выводит названия всех веток + название последнего коммита в них, показывает текующую ветку и на сколько комитов она впереди удаленного репо
- `git branch <newbranchname>` - создание новой ветки с именем *newbranchname*
- `git checkout <existingbranchname>` - переключаемся с текущей ветки на ветку с именем *existingbranchname*
- `git checkout -b <newbranchname>` =  git branch + git checkout - создает новую ветку с именем *newbranchname* и сразу на нее переключается

### 3.3. Команда checkout при незакоммиченных изменениях

При незакомиченных изменениях при попытке перехода на другую ветку c помощью `git checkout <existingbranchname>` git выдаст ошибку, в случае, если файлы с незакомиченными изменениями в разный ветках в разном состоянии. 
```zsh
error: Your local changes to the following files would be overwritten by checkout:
        script.js
Please commit your changes or stash them before you switch branches.
Aborting
```
при этом, если для коммита изменения еще не готовы, а переключиться на другую ветку всё равно нужно, если несколько способов: 

- `git checkout -f <anotherbranchname>` = `git checkout --force <anotherbranchname>` - переключает на другую ветку, незакомиченные изменения удаляются
- `git checkout -f` - просто удалит все незакомиченные изменения и вернется к состоянию последнего коммита на текущей ветке

- `git stash` - убирает из рабочей дирректории незакоммиченные изменения и архивирует их, можно переходить на другую ветку и работать
- `git stash pop` - возвращает незакомиченные изменения из архива в рабочую дирректорию. Изменения сохраненные в stash не привязаны к конкретной ветке, и можно их вставить и в другую, но, если там файлы отличались от исходной - может возникнуть конфликт.

... если файл с незакомиченными изменениями в другой ветке аналогичен последнему комиту в текущей `git checkout` сработает без ошибки :ok_hand: и незакомиченные изменения перетянутся на другую ветку. Иногда это полезно, но иногда может привести к тому, что работа предназначенная для одной ведки нечаянно попадет в другую.

### 3.4. Перенос незакоммиченных изменений

если мы работаем на одной ветке и понимаем, что изменения в ней тянут на создание отдельной ветки, то до коммита можно переключиться на новую ветку, все изменения туда перетянутся, и можно будет сделать коммит уже там

- `git checkout -b <fix>` и `git commit -ma 'new changes'` - создаем новую ветку *fix*, переключаемся на нее и отправляем коммит уже в нее

### 3.5. Перенос веток "вручную"

В ситуации когда мы уже сделали несколько комитов в текущей ветке (например, master), но в тоге решили что эти изменения подходят для новой ветки. Можно это сделать:

- `git branch <newbrancname>` - для этого создаем новую ветку 
- `git checkout <thesamenewbrancname>` - переключаемся на нее (она остается на последнем комите)
- `git branch -f <master> <54a4>` - ветку мастер сносим на нужное количество комитов вниз (смотрим в истории номер комитов), флаг -f нужен чтобы избежать ошибки "такая ветка уже существует", а флаг -f делает возможным перенос уже существующей ветки на другой коммит.
    
- `git chechout -B <master> <54a4>` =`git branch -f <master> <54a4>` + `git checkout <master>`

- `git branch -f <master> <fix>` - перенесет ветку master в последний комит ветки fix. Второй параметр это идентификатор комита, но если вметсо номера мы указываем имя ветки - то git найдет последний комит в этой ветке и поставит переносимую ветку туда.
  
### 3.6. Состояние отделённой HEAD

- `git checkout <commitid>` - позволяет переключиться на предыдущие коммиты, чтобы постмотреть на состояние проекта в прошлом. При этом мы переходим в Detached HEAD state - и git выдаст нам соответствующее предупреждение. Комиты сделаные в этом состоянии не будут относиться ни к какой ветке, и со временем будут удалены. Чтобы этого не произошло можно создать ветку на них. Или выборочно перенести эти комиты на другие ветки (cherry-pick). 
- `git branch <newbranchname> <commitnumber>` - номер комита можно взять из сообщения git c предупреждением об утере комита в Detached HEAD state и создать на нем новую ветку.
- `git cherry-pick <commitnumber>` - позволяет взять изменения в указаном комите на другую ветку

### 3.7. Восстановление предыдущих версий файлов

-`git checkout <commitid> <fileorsrcpath>` - вытягивает нам состояние указанных файлов из истории указанного коммита и автоматически добавляет его в INDEX, остальные файл остаются в текущем состоянии. 
- `git reset <fileorsrcpath> - убирает файл из INDEX, если мы не хотим чтобы он попал в коммит
-`git checkout HEAD <fileorsrcpath>` - отобразит в рабочей дирректории указанный файл к состоянию HEAD (последнего комита) и добавит эту же версию в INDEX
-`git checkout <fileorsrcpath>` - тоже саоме но без указания комита (НEAD или id) - отобразит в рабочей дирректории указанный файл к состоянию из INDEX]
- `git checkout <commitidorlinkasbranchname> <filepath>` - если есть совпадающие названия файла и ветки, то по умолчанию первый параметр проверяется на наличие такой ветки и соответствующего ей коммита, а уже потом файл... если мы хотим передать только имя файла, то избежать совпадения с веткой можно поставив `--`
- `git checkout --  <filepath>` - в этом случае даже, если у нас есть ветка с таким же именем как и файл, название будет принято за название файла

### 3.8. Просмотр истории и старых файлов, символы ~, ^, @, поиск с :/

-`git log` - выводит информацию об истории коммитов (по умолчанию начиная от HEAD, т.е. с текущей ветки, но можно передать и ссылку на конкретный коммит/ветку)
    -`git log --oneline` - выводит краткую информацию "по одной строке на каждый коммит"
    -`git log <branchname> --oneline` - выводит краткую информацию о коммитах начиная с верху указанной ветки 
-`git show` - выводит информацию о коммите на который указывает HEAD (общая инфо о коммите и внесенные изменения)
    -`git show <commitidorbranchname>` - выводит информацию об указанном коммите или о последнем комите в указаной ветке
        -`git show <commitidorbranchname>~4` - выводит инфо о коммите, который находится в истории на 4 ниже/раньше указанного по id или названию ветки
            - `git show <commitidorbranchname>~4 --quiet` - c флагом `--quiet` команда выводит только основную информацию по комиту (без перечня изменений в нем)
            - `git show main~~:index.html` - покажет состояние файла index.html в коммите на 2 ниже вершины ветки main
            - `git show :index.html` - покажет состояние файла index.html в Index (имеет смысл, если мы уже проиндексировали изменения в файле, а потом изменили еще что-то и хотим сравнить)
            -`git show /:<stringfromcommitdescription>` - покажет самый свежий коммит из всего репо содержащий в описании <stringfromcommitdescription> (если ищем несколько слов - берем в '' )

В любых коммандах символ тильда `~`=`~1`, `~~`=`~2`, `~~~`=`~3` и т.д. дает доступ к родительским коммитам, т.е. к комиту, который находится на 1, 2, 3 или более комиттов ниже указанного. 
При этом HEAD можно заменить на `@` и указывать например: `@~~` = коммит на два ниже HEAD (для Windows Power Shell добавляем ковычки `'@~~'` потому что `@` там это специальный символ)

### 3.9. Слияние веток "перемоткой"
- `git merge <branchname>` - сделает fast-forward merge: перенесет верхушку текущей ветки к верхушке указанной <branchname> ветки и записывает id commita, где она была до этого в .git/ORIG_HEAD
- `cat .git/ORIG_HEAD` - покажет номер коммита, где была верхушка ветки до последнего (merge), vj;
- `git branch -f <main> ORIG_HEAD` - переключет ветку main на номер коммита сохраненный в .git/ORIG_HEAD (сначала с main надо переключиться на другую любую ветку, а потом можно вернуться обратно с помощью `git checkout main`)
- `git checkout -B <branchname1> <branchname2>` - даст такой же результат, как и `git merge <branchname2>` вызваный на <branchname1> - передвинет верхушку первой ветки на верхушку второй

![git logo](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Git-logo.svg/1920px-Git-logo.svg.png)
---
